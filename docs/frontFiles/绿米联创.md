# 绿米联创

## 1. 小程序/H5页面响应式布局

### 各单位特点与应用场景

#### px (像素)
- **特点**：绝对单位，固定像素值
- **应用**：精确控制元素尺寸，不随设备变化
- **劣势**：缺乏响应性，不同设备显示效果不一致

#### rem (相对根元素)
- **特点**：相对于根元素(html)的字体大小
- **应用**：H5全局响应式布局的首选方案
- **实现方式**：

```javascript
// rem适配核心实现
(function flexible(window, document) {
  const docEl = document.documentElement;
  
  // 设置1rem = viewWidth / 10
  function setRemUnit() {
    const rem = docEl.clientWidth / 10;
    docEl.style.fontSize = rem + 'px';
  }
  
  setRemUnit();
  
  // 窗口变化时重新计算
  window.addEventListener('resize', setRemUnit);
  window.addEventListener('pageshow', function(e) {
    if (e.persisted) {
      setRemUnit();
    }
  });
})(window, document);
```

#### em (相对父元素)
- **特点**：相对于父元素的字体大小
- **应用**：局部响应式布局，特别是组件内部元素缩放
- **优势**：可以构建更好的组件封装，便于局部缩放

#### rpx (响应式像素，小程序专用)
- **特点**：以750rpx为标准宽度，自动适应不同屏幕
- **应用**：微信小程序首选单位
- **换算**：1rpx = 屏幕宽度/750像素
- **示例**：在iPhone6上，1rpx = 0.5px

#### vw/vh (视口宽度/高度百分比)
- **特点**：相对于视口的单位，100vw等于视口宽度
- **应用**：现代H5响应式布局，无需JavaScript辅助
- **浏览器支持**：现代浏览器支持良好

### 最佳实践与选择策略

#### 小程序
```css
/* 微信小程序推荐使用rpx */
.container {
  width: 750rpx;  /* 始终等于屏幕宽度 */
  padding: 30rpx;
  margin-bottom: 20rpx;
}

.title {
  font-size: 40rpx;
  line-height: 56rpx;
}
```

#### H5端
```css
/* H5端推荐rem+vw混合策略 */
html {
  font-size: 10vw;  /* 1rem = 10% 视口宽度 */
}

.container {
  width: 100%;
  padding: 0.5rem;
}

.title {
  font-size: 1.2rem;
  line-height: 1.5;
}

/* 媒体查询限制最大尺寸 */
@media screen and (min-width: 540px) {
  html {
    font-size: 54px;  /* 540px × 10% = 54px */
  }
}
```

### 多端统一适配策略

对于同时开发小程序和H5的项目：

1. **设计稿统一**: 以750px宽度为标准
2. **单位选择**:
   - 小程序：使用rpx
   - H5：使用rem或vw
3. **统一转换工具**:
   ```javascript
   // 统一px到rem或rpx的函数
   function pxTransform(size, targetPlatform = 'h5') {
     if (targetPlatform === 'h5') {
       return size / 75 + 'rem';  // 假设1rem = 75px
     } else {
       return size + 'rpx';  // 小程序中直接使用rpx
     }
   }
   ```
4. **针对特殊设备的优化**:
   ```css
   /* 针对iPhone X等刘海屏的安全区域适配 */
   @supports (padding-bottom: constant(safe-area-inset-bottom)) {
     .footer {
       padding-bottom: constant(safe-area-inset-bottom);
     }
   }
   
   @supports (padding-bottom: env(safe-area-inset-bottom)) {
     .footer {
       padding-bottom: env(safe-area-inset-bottom);
     }
   }
   ```

## 2. 小程序/H5常用布局

### Flex布局
最常用且强大的布局方式，支持各种复杂排列：

```css
.container {
  display: flex;
  flex-direction: row;          /* 主轴方向 */
  justify-content: space-between; /* 主轴对齐方式 */
  align-items: center;          /* 交叉轴对齐方式 */
  flex-wrap: wrap;              /* 是否换行 */
}

/* 子项目控制 */
.item {
  flex: 1;                     /* 弹性增长比例 */
  order: 2;                    /* 显示顺序 */
  align-self: flex-start;       /* 单独的对齐方式 */
}
```

**适用场景**：
- 导航栏
- 内容卡片
- 列表项
- 表单布局

### Grid布局
二维网格布局系统，适合复杂页面结构：

```css
.grid-container {
  display: grid;
  grid-template-columns: repeat(4, 1fr);   /* 4列等宽布局 */
  grid-template-rows: auto 200px 1fr;      /* 行高定义 */
  gap: 10px;                               /* 行列间距 */
  grid-template-areas:                      /* 区域命名 */
    "header header header header"
    "sidebar content content content"
    "footer footer footer footer";
}

/* 区域定位 */
.header { grid-area: header; }
.sidebar { grid-area: sidebar; }
.content { grid-area: content; }
.footer { grid-area: footer; }

/* 响应式网格 */
@media (max-width: 768px) {
  .grid-container {
    grid-template-columns: 1fr;
    grid-template-areas:
      "header"
      "content"
      "sidebar"
      "footer";
  }
}
```

**适用场景**：
- 仪表盘
- 图片画廊
- 复杂表单
- 整体页面框架

### 瀑布流布局
内容高度不一致的图片或卡片排列：

```css
/* CSS方法1: 使用column实现简单瀑布流 */
.waterfall {
  column-count: 3;    /* 列数 */
  column-gap: 16px;   /* 列间距 */
}

.item {
  break-inside: avoid; /* 防止项目内部断开 */
  margin-bottom: 16px;
}

/* CSS方法2: 使用grid实现自动填充的瀑布流 */
.waterfall-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  grid-gap: 16px;
  grid-auto-flow: dense; /* 紧密填充 */
}
```

**JavaScript辅助瀑布流**：
```javascript
// 更精确的瀑布流布局计算
function arrangeWaterfall() {
  const container = document.querySelector('.waterfall');
  const items = Array.from(container.children);
  const columnCount = 3;
  const columnHeights = Array(columnCount).fill(0);
  
  // 设置每个元素的位置
  items.forEach(item => {
    // 找出高度最小的列
    const minHeightColumn = columnHeights.indexOf(Math.min(...columnHeights));
    
    // 设置元素位置
    item.style.position = 'absolute';
    item.style.top = `${columnHeights[minHeightColumn]}px`;
    item.style.left = `${minHeightColumn * (100 / columnCount)}%`;
    item.style.width = `${100 / columnCount - 2}%`; // 减去间距
    
    // 更新该列高度
    columnHeights[minHeightColumn] += item.offsetHeight + 16; // 加上间距
  });
  
  // 设置容器高度
  container.style.height = `${Math.max(...columnHeights)}px`;
}
```

### 经典三栏布局
内容居中，两侧固定宽度：

```css
/* 1. 使用flex实现 */
.three-column-flex {
  display: flex;
}
.sidebar-left { width: 200px; }
.content { flex: 1; }
.sidebar-right { width: 200px; }

/* 2. 使用grid实现 */
.three-column-grid {
  display: grid;
  grid-template-columns: 200px 1fr 200px;
}

/* 3. 使用float实现(兼容性好) */
.three-column-float .content {
  margin: 0 200px; /* 左右margin等于侧栏宽度 */
}
.three-column-float .sidebar-left {
  float: left;
  width: 200px;
}
.three-column-float .sidebar-right {
  float: right;
  width: 200px;
}
```

### 小程序特有布局

#### 顶部搜索框+滚动内容
```html
<view class="container">
  <view class="search-bar">
    <input type="text" placeholder="搜索" />
  </view>
  <scroll-view scroll-y class="content">
    <!-- 滚动内容 -->
    <view class="item" wx:for="{{list}}" wx:key="id">{{item.name}}</view>
  </scroll-view>
</view>

<style>
.container {
  height: 100vh;
  display: flex;
  flex-direction: column;
}
.search-bar {
  height: 50px;
  padding: 10px;
  background: #fff;
}
.content {
  flex: 1;
  overflow: hidden;
}
</style>
```

#### 底部固定导航
```html
<view class="page">
  <scroll-view scroll-y class="main-content">
    <!-- 主内容 -->
  </scroll-view>
  <view class="footer">
    <view class="tab-item">首页</view>
    <view class="tab-item">分类</view>
    <view class="tab-item">购物车</view>
    <view class="tab-item">我的</view>
  </view>
</view>

<style>
.page {
  height: 100vh;
  display: flex;
  flex-direction: column;
}
.main-content {
  flex: 1;
  overflow: hidden;
}
.footer {
  height: 50px;
  display: flex;
  background: #fff;
  box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
}
.tab-item {
  flex: 1;
  text-align: center;
  line-height: 50px;
}
</style>
```

## 3. 项目中CSS规范处理

### 命名规范体系

#### BEM命名法
Block-Element-Modifier模式:

```css
/* Block: 独立实体 */
.card { }

/* Element: 元素，属于block的一部分 */
.card__title { }
.card__image { }

/* Modifier: 修饰符，改变状态或样式 */
.card--featured { }
.card__button--disabled { }
```

#### OOCSS (面向对象CSS)
将结构和皮肤分离:

```css
/* 结构 */
.btn {
  display: inline-block;
  padding: 6px 12px;
  border-radius: 3px;
}

/* 皮肤 */
.btn-primary {
  background: blue;
  color: white;
}

.btn-danger {
  background: red;
  color: white;
}
```

### CSS预处理器使用

#### SASS/SCSS规范

```scss
// 变量定义
$primary-color: #3498db;
$border-radius: 4px;
$font-stack: 'Roboto', sans-serif;

// 嵌套与父选择器引用
.card {
  border-radius: $border-radius;
  
  &__header {
    background-color: $primary-color;
  }
  
  &__body {
    padding: 15px;
  }
  
  &--featured {
    box-shadow: 0 10px 20px rgba(0,0,0,0.2);
  }
}

// 混合宏(Mixins)
@mixin flex-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal {
  @include flex-center;
  // 其他样式...
}

// 函数
@function calculate-width($columns) {
  @return $columns * 8.333%;
}

.column-3 {
  width: calculate-width(3); // 25%
}
```

### CSS模块化方案

#### CSS Modules
```javascript
// React中使用CSS Modules
import styles from './Button.module.css';

function Button() {
  return <button className={styles.primary}>Click me</button>;
}
```

#### Vue Scoped CSS
```vue
<template>
  <button class="button primary">Click me</button>
</template>

<style scoped>
.button {
  padding: 10px 15px;
  border-radius: 4px;
}
.primary {
  background: blue;
  color: white;
}
</style>
```

#### CSS-in-JS
```javascript
// styled-components示例
import styled from 'styled-components';

const Button = styled.button`
  background: ${props => props.primary ? 'blue' : 'white'};
  color: ${props => props.primary ? 'white' : 'black'};
  padding: 10px 15px;
  border-radius: 4px;
  
  &:hover {
    opacity: 0.9;
  }
`;

function App() {
  return <Button primary>Click me</Button>;
}
```

### 工程化工具链

#### PostCSS配置
```javascript
// postcss.config.js
module.exports = {
  plugins: [
    require('autoprefixer')({
      browsers: ['> 1%', 'last 2 versions']
    }),
    require('cssnano')({
      preset: 'default',
    }),
    require('postcss-preset-env')({
      stage: 3,
      features: {
        'nesting-rules': true
      }
    })
  ]
}
```

#### StyleLint规则配置
```javascript
// .stylelintrc
{
  "extends": "stylelint-config-standard",
  "rules": {
    "indentation": 2,
    "color-hex-case": "lower",
    "selector-class-pattern": "^[a-z][a-zA-Z0-9]+$|^[a-z][a-z0-9\\-\\_]+[a-z0-9]$",
    "no-descending-specificity": null,
    "at-rule-no-unknown": [true, {
      "ignoreAtRules": ["include", "mixin", "extend", "function", "return"]
    }]
  }
}
```

### 组件级CSS架构

#### 组件CSS变量系统
```css
/* 定义组件变量 */
.btn {
  --button-padding: 10px 15px;
  --button-radius: 4px;
  --button-primary: #3498db;
  --button-text: white;
  
  padding: var(--button-padding);
  border-radius: var(--button-radius);
  background: var(--button-primary);
  color: var(--button-text);
}

/* 主题覆盖 */
.dark-theme .btn {
  --button-primary: #2c3e50;
}
```

#### 组件级CSS样例
```scss
// card-component.scss
.c-card {
  &__header {
    padding: 1rem;
    border-bottom: 1px solid #eee;
  }
  
  &__body {
    padding: 1rem;
  }
  
  &__footer {
    padding: 1rem;
    border-top: 1px solid #eee;
  }
  
  // 修饰符
  &--compact {
    .c-card__header,
    .c-card__body,
    .c-card__footer {
      padding: 0.5rem;
    }
  }
  
  // 状态
  &.is-loading {
    opacity: 0.7;
    pointer-events: none;
  }
}
```

### 实际项目CSS管理策略

1. **分层CSS文件结构**:
   ```
   styles/
   ├── base/           # 基础样式、重置、变量
   │   ├── reset.scss
   │   ├── variables.scss
   │   └── typography.scss
   ├── components/     # 组件样式
   │   ├── button.scss
   │   ├── card.scss
   │   └── form.scss
   ├── layouts/        # 布局样式
   │   ├── header.scss
   │   ├── footer.scss
   │   └── grid.scss
   ├── pages/          # 页面特定样式
   │   ├── home.scss
   │   └── about.scss
   ├── utils/          # 工具类和mixins
   │   ├── mixins.scss
   │   └── helpers.scss
   └── main.scss       # 主入口文件
   ```

2. **性能优化策略**:
   - 使用简化选择器，避免过深的嵌套
   - 避免使用`*`选择器
   - 使用简写属性
   - 利用继承减少重复代码

3. **移动端优化**:
   - 避免使用大量阴影和渐变
   - 优先使用transform和opacity进行动画
   - 谨慎使用固定定位(fixed)
   - 媒体查询断点统一管理

## 4. Vue2和Vue3双向绑定的区别，组合式API优点

### 双向绑定实现原理

#### Vue2: Object.defineProperty

```javascript
// Vue2响应式系统简化实现
function observe(obj) {
  if (!obj || typeof obj !== 'object') return;
  
  Object.keys(obj).forEach(key => {
    let value = obj[key];
    let dep = new Dep(); // 依赖收集器
    
    // 递归观察属性值
    observe(value);
    
    Object.defineProperty(obj, key, {
      get() {
        // 依赖收集：添加订阅者
        if (Dep.target) dep.addSub(Dep.target);
        return value;
      },
      set(newValue) {
        if (value === newValue) return;
        value = newValue;
        
        // 递归观察新值
        observe(newValue);
        
        // 通知更新
        dep.notify();
      }
    });
  });
}
```

**局限性**:
- 无法检测对象属性的添加和删除
- 无法直接监听数组索引和长度变化
- 对于大型对象，初始化时需要递归遍历，性能开销大

**解决方法**:
```javascript
// Vue2中添加响应式属性
Vue.set(obj, key, value);
// 或
this.$set(obj, key, value);

// 删除响应式属性
Vue.delete(obj, key);
// 或
this.$delete(obj, key);
```

#### Vue3: Proxy

```javascript
// Vue3响应式系统简化实现
function reactive(target) {
  if (typeof target !== 'object' || target === null) {
    return target;
  }
  
  const handler = {
    get(target, key, receiver) {
      // 依赖收集
      track(target, key);
      
      const result = Reflect.get(target, key, receiver);
      
      // 深度响应
      if (typeof result === 'object' && result !== null) {
        return reactive(result);
      }
      
      return result;
    },
    set(target, key, value, receiver) {
      // 获取旧值
      const oldValue = target[key];
      
      // 设置新值
      const result = Reflect.set(target, key, value, receiver);
      
      // 如果值发生变化，触发更新
      if (oldValue !== value) {
        trigger(target, key);
      }
      
      return result;
    },
    deleteProperty(target, key) {
      // 检查属性是否存在
      const hasKey = key in target;
      
      // 删除属性
      const result = Reflect.deleteProperty(target, key);
      
      // 如果属性存在且删除成功，触发更新
      if (hasKey && result) {
        trigger(target, key);
      }
      
      return result;
    }
  };
  
  return new Proxy(target, handler);
}
```

**优势**:
- 可以检测对象属性的添加和删除
- 可以检测数组索引和长度变化
- 不需要初始化时递归遍历，性能更好
- 提供了更丰富的拦截操作(13种拦截方法)

**示例对比**:

```javascript
// Vue2
let data = { count: 0 };
let vm = new Vue({
  data: data
});
// 后添加的属性不是响应式的
vm.newProp = 'hi';  // 不会触发视图更新

// Vue3
const state = reactive({ count: 0 });
// 后添加的属性也是响应式的
state.newProp = 'hi';  // 会触发视图更新
```

### 组合式API (Composition API) 优点

#### 1. 更好的逻辑组织与复用

**选项式API问题**:
```javascript
// Vue2 选项式API - 功能分散在不同选项中
export default {
  data() {
    return {
      user: { id: 1, name: 'John' },
      posts: [],
      loading: false
    };
  },
  created() {
    this.fetchUserPosts();
  },
  methods: {
    fetchUserPosts() {
      this.loading = true;
      fetch(`/api/users/${this.user.id}/posts`)
        .then(res => res.json())
        .then(data => {
          this.posts = data;
          this.loading = false;
        });
    }
  },
  computed: {
    hasNoPost() {
      return this.posts.length === 0;
    }
  }
};
```

**组合式API解决方案**:
```javascript
// Vue3 组合式API - 功能逻辑集中
import { ref, computed, onMounted } from 'vue';

export function useUserPosts(userId) {
  const posts = ref([]);
  const loading = ref(false);
  
  const hasNoPosts = computed(() => posts.value.length === 0);
  
  const fetchUserPosts = () => {
    loading.value = true;
    fetch(`/api/users/${userId}/posts`)
      .then(res => res.json())
      .then(data => {
        posts.value = data;
        loading.value = false;
      });
  };
  
  onMounted(fetchUserPosts);
  
  return {
    posts,
    loading,
    hasNoPosts,
    fetchUserPosts
  };
}

// 在组件中使用
export default {
  setup() {
    const user = ref({ id: 1, name: 'John' });
    const { posts, loading, hasNoPosts } = useUserPosts(user.value.id);
    
    return {
      user,
      posts,
      loading,
      hasNoPosts
    };
  }
};
```

#### 2. TypeScript支持更友好

**Vue2中TypeScript使用**:
```typescript
// Vue2 + TypeScript
import Vue from 'vue';
import Component from 'vue-class-component';

@Component
export default class UserComponent extends Vue {
  user: { id: number; name: string } = { id: 1, name: 'John' };
  posts: any[] = [];
  
  get hasNoPosts(): boolean {
    return this.posts.length === 0;
  }
  
  fetchUserPosts(): void {
    // ...
  }
  
  created(): void {
    this.fetchUserPosts();
  }
}
```

**Vue3中TypeScript使用**:
```typescript
// Vue3 + TypeScript + Composition API
import { ref, computed, onMounted, Ref, ComputedRef } from 'vue';

interface User {
  id: number;
  name: string;
}

interface Post {
  id: number;
  title: string;
  content: string;
}

function useUserPosts(userId: number) {
  const posts: Ref<Post[]> = ref([]);
  const loading: Ref<boolean> = ref(false);
  
  const hasNoPosts: ComputedRef<boolean> = computed(() => posts.value.length === 0);
  
  const fetchUserPosts = (): void => {
    loading.value = true;
    fetch(`/api/users/${userId}/posts`)
      .then(res => res.json())
      .then((data: Post[]) => {
        posts.value = data;
        loading.value = false;
      });
  };
  
  onMounted(fetchUserPosts);
  
  return {
    posts,
    loading,
    hasNoPosts,
    fetchUserPosts
  };
}
```

#### 3. 更好的按需引入与Tree-shaking

```javascript
// Vue3 按需引入API，打包时可以Tree-shaking未使用的API
import { ref, onMounted } from 'vue';  // 仅引入需要的API

// 而不是
import Vue from 'vue';  // 引入整个Vue
```

#### 4. 解决了Vue2中的this指向问题

**Vue2中的this问题**:
```javascript
// Vue2中this指向问题
export default {
  data() {
    return { count: 0 };
  },
  methods: {
    increment() {
      this.count++;
    },
    handleClick() {
      // 在异步回调中this可能丢失
      setTimeout(function() {
        this.count++;  // 错误: this指向window或undefined
      }, 1000);
      
      // 解决方法1: 使用箭头函数
      setTimeout(() => {
        this.count++;  // 正确
      }, 1000);
      
      // 解决方法2: 保存this引用
      const vm = this;
      setTimeout(function() {
        vm.count++;  // 正确
      }, 1000);
    }
  }
};
```

**Vue3中没有this问题**:
```javascript
// Vue3中无this指向问题
import { ref } from 'vue';

export default {
  setup() {
    const count = ref(0);
    
    function increment() {
      count.value++;
    }
    
    function handleClick() {
      // 无需担心this指向问题
      setTimeout(function() {
        count.value++;  // 始终正确
      }, 1000);
    }
    
    return {
      count,
      increment,
      handleClick
    };
  }
};
```

#### 5. 更灵活的逻辑提取与组合

```javascript
// 将多个composables组合使用
import { useUserPosts } from './useUserPosts';
import { useUserProfile } from './useUserProfile';
import { useNotifications } from './useNotifications';

export default {
  setup() {
    // 用户文章逻辑
    const { posts, loading: postsLoading } = useUserPosts(1);
    
    // 用户资料逻辑
    const { profile, loading: profileLoading } = useUserProfile(1);
    
    // 通知系统逻辑
    const { notifications, markAsRead } = useNotifications();
    
    // 组合逻辑
    const isLoading = computed(() => postsLoading.value || profileLoading.value);
    
    return {
      // 暴露所需数据和方法
      posts,
      profile,
      notifications,
      isLoading,
      markAsRead
    };
  }
};
```

## 5. watch和watchEffect区别

### watch

```javascript
// Vue3中的watch
import { ref, watch } from 'vue';

const count = ref(0);
const name = ref('John');

// 监视单个数据源
watch(count, (newValue, oldValue) => {
  console.log(`Count changed from ${oldValue} to ${newValue}`);
}, { immediate: true, deep: true });

// 监视多个数据源
watch([count, name], ([newCount, newName], [oldCount, oldName]) => {
  console.log(`Count: ${oldCount} -> ${newCount}, Name: ${oldName} -> ${newName}`);
});

// 监视getter函数
watch(
  () => count.value + 10,
  (newValue, oldValue) => {
    console.log(`Expression result changed: ${oldValue} -> ${newValue}`);
  }
);
```

**watch特点**:
- **明确性**: 明确指定要监视的数据源
- **懒执行**: 默认只在数据源变化时执行回调
- **可访问新旧值**: 回调接收新值和旧值作为参数
- **可配置选项**: 
  - `immediate`: 是否立即执行一次回调
  - `deep`: 是否深度监视对象内部属性变化
  - `flush`: 回调的刷新时机 ('pre', 'post', 'sync')

### watchEffect

```javascript
// Vue3中的watchEffect
import { ref, watchEffect } from 'vue';

const count = ref(0);
const name = ref('John');
const result = ref(0);

// 自动追踪依赖
watchEffect(() => {
  // 此函数内使用的响应式状态会被自动追踪
  result.value = count.value * 2;
  console.log(`Name is ${name.value}, count is ${count.value}`);
  // 无需显式列出依赖
});

// 停止监听
const stop = watchEffect(() => { /* ... */ });
// 之后可以调用stop()停止监听

// 清理副作用
watchEffect((onCleanup) => {
  const timer = setTimeout(() => {
    console.log('Delayed effect');
  }, 1000);
  
  // 在effect重新执行或停止前调用
  onCleanup(() => clearTimeout(timer));
});

// 控制执行时机
watchEffect(() => { /* DOM更新前执行 */ });

watchEffect(() => { /* DOM更新后执行 */ }, {
  flush: 'post'
});
```

**watchEffect特点**:
- **自动依赖跟踪**: 自动追踪函数内使用的所有响应式状态
- **立即执行**: 创建时立即执行一次回调函数
- **无法访问旧值**: 只能访问当前值，不提供旧值
- **简洁**: 不需要显式指定依赖列表
- **适合副作用操作**: 适合处理异步请求、DOM操作等副作用

### 详细对比分析

#### 1. 依赖收集方式

**watch**: 
- 显式声明数据源，只有指定的数据源变化才触发回调
- 可以监视具有返回值的getter函数

```javascript
// 只有count变化时触发
watch(count, () => {
  // 此回调不会因name变化而触发
  console.log(name.value);
});
```

**watchEffect**: 
- 自动收集函数内的响应式依赖
- 函数内使用的任何响应式状态变化都会触发重新执行

```javascript
// count或name任一变化都会触发
watchEffect(() => {
  console.log(`${count.value}, ${name.value}`);
});
```

#### 2. 执行时机

**watch**:
- 默认懒执行，只在数据源变化时触发
- 通过`immediate: true`选项可以在创建时立即执行一次

**watchEffect**:
- 创建时立即执行一次收集依赖
- 之后在任何依赖变化时重新执行

#### 3. 回调参数

**watch**:
```javascript
watch(count, (newCount, oldCount) => {
  // 可以访问变化前后的值
  console.log(`Changed from ${oldCount} to ${newCount}`);
});
```

**watchEffect**:
```javascript
watchEffect(() => {
  // 只能访问当前值，没有旧值参数
  console.log(`Current count: ${count.value}`);
});
```

#### 4. 使用场景对比

**适合watch的场景**:
- 需要比较变化前后的值
- 只在特定数据变化时执行逻辑
- 需要控制回调是否立即执行
- 监视复杂表达式而不执行副作用

```javascript
// 例：仅当用户ID变化时加载数据
watch(userId, (newId, oldId) => {
  if (newId !== oldId) {
    fetchUserData(newId);
  }
});
```

**适合watchEffect的场景**:
- 需要自动追踪多个依赖
- 需要在组件初始化和依赖变化时执行相同逻辑
- 副作用逻辑依赖多个响应式状态
- 代码更简洁，不关心新旧值对比

```javascript
// 例：自动同步查询参数和结果
watchEffect(() => {
  // 任何查询参数变化都会触发
  const params = {
    category: category.value,
    search: searchQuery.value,
    page: currentPage.value
  };
  fetchResults(params);
});
```

#### 5. 性能考虑

**watch**:
- 只有指定的数据源变化时才执行，可能更高效
- 适合监听大型对象但只关注特定属性的场景

**watchEffect**:
- 回调中使用的所有响应式数据变化都会触发执行
- 当依赖较多时可能导致不必要的重复执行

## 6. Vue和React区别

### 核心设计理念

#### Vue:
- **渐进式框架**: 可以逐步采用，从简单应用到复杂系统
- **声明式渲染**: 扩展的HTML模板语法
- **响应式系统**: 自动追踪依赖变化
- **双向绑定**: v-model简化表单操作

#### React:
- **"UI即函数"思想**: UI = f(state)
- **单向数据流**: 自上而下的props传递
- **JSX**: JavaScript的语法扩展
- **函数式编程**: 推崇纯函数和不可变数据

### 组件定义与模板语法

#### Vue:
```vue
<!-- Vue单文件组件 -->
<template>
  <div class="counter">
    <p>Count: {{ count }}</p>
    <button @click="increment">Increment</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    };
  },
  methods: {
    increment() {
      this.count++;
    }
  }
}
</script>

<style scoped>
.counter {
  text-align: center;
}
</style>
```

#### React:
```jsx
// React函数式组件
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  function increment() {
    setCount(count + 1);
  }
  
  return (
    <div className="counter">
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

// 样式需要单独处理
// 可以使用CSS模块、styled-components等
```

### 状态管理与更新

#### Vue:
- **数据模型**: 响应式数据，直接修改状态触发更新
- **Vuex/Pinia**: 集成度高的状态管理库
- **更新机制**: 精确依赖追踪，最小化更新范围

```js
// Vue直接修改状态
this.count++; // 自动触发视图更新

// Vue3 Composition API
const count = ref(0);
count.value++; // 自动触发视图更新
```

#### React:
- **数据不可变性**: 不直接修改状态，而是创建新状态
- **Redux/Mobx**: 外部状态管理库，集成需额外配置
- **更新机制**: 状态变化引发组件重新渲染，通过diff算法更新DOM

```js
// React状态更新
// 错误方式
// state.count++; // 不会触发更新

// 正确方式
setCount(count + 1); // 创建新状态，触发组件重新渲染

// 复杂对象
setUser(prevUser => ({
  ...prevUser,
  age: prevUser.age + 1
}));
```

### 生命周期对比

#### Vue2:
```js
export default {
  beforeCreate() {},
  created() {},
  beforeMount() {},
  mounted() {},
  beforeUpdate() {},
  updated() {},
  beforeDestroy() {},
  destroyed() {}
}
```

#### Vue3:
```js
import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from 'vue';

export default {
  setup() {
    onBeforeMount(() => {});
    onMounted(() => {});
    onBeforeUpdate(() => {});
    onUpdated(() => {});
    onBeforeUnmount(() => {});
    onUnmounted(() => {});
  }
}
```

#### React:
```jsx
// 类组件生命周期
class Component extends React.Component {
  constructor() {}
  componentDidMount() {}
  componentDidUpdate() {}
  componentWillUnmount() {}
  render() {}
}

// 函数组件使用Hooks
function Component() {
  useEffect(() => {
    // componentDidMount和componentDidUpdate
    return () => {
      // componentWillUnmount
    };
  }, [dependencies]);
}
```

### 渲染性能优化

#### Vue:
- **自动依赖追踪**: 精确知道哪些组件需要重新渲染
- **内置优化**: 自动记忆化，开发者无需频繁手动优化
- **异步渲染队列**: 批量处理更新

```js
// Vue自动追踪依赖，无需手动优化
data() {
  return { count: 0 };
}
// 只有使用了count的组件会更新
```

#### React:
- **手动优化**: 需要开发者主动使用优化手段
- **记忆化工具**: React.memo, useMemo, useCallback
- **虚拟DOM差异算法**: 计算最小DOM更新

```jsx
// React需要手动优化
// 防止不必要的重渲染
const MemoizedComponent = React.memo(Component);

// 缓存计算结果
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

// 缓存回调函数
const memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);
```

### 工具链与生态系统

#### Vue:
- **Vue CLI/Vite**: 官方维护的工具链
- **Vue Router**: 官方路由库
- **Vuex/Pinia**: 官方状态管理库
- **单文件组件**: .vue文件将HTML、JS、CSS集成

#### React:
- **Create React App**: 社区维护的工具链
- **React Router**: 社区维护的路由库
- **Redux/MobX**: 社区维护的状态管理库
- **JSX**: JS和HTML混合语法，样式通常分离

### 企业实践中的区别

#### 适合Vue的场景:
- 快速开发和原型设计
- 渐进增强已有项目
- 追求更短的学习曲线
- 喜欢HTML模板的开发者
- 更多的约定优于配置

#### 适合React的场景:
- 大型复杂应用
- 团队熟悉函数式编程
- 喜欢JavaScript中心的开发
- 需要React Native跨平台能力
- 追求最大的灵活性和可扩展性

## 7. Vuex/Pinia底层实现

### Vuex核心原理

#### 1. 响应式状态管理

Vuex利用Vue的响应式系统使状态具有响应式特性：

```js
// Vuex核心实现示意
class Store {
  constructor(options) {
    // 响应式状态
    this._vm = new Vue({
      data: {
        $$state: options.state || {}
      }
    });
    
    // 存储getters
    this._getters = {};
    // 初始化getters
    const store = this;
    const computed = {};
    
    // 注册getters为计算属性
    forEachValue(options.getters, (fn, key) => {
      computed[key] = () => fn(store.state);
      Object.defineProperty(store.getters, key, {
        get: () => store._vm[key]
      });
    });
    
    // 创建Vue实例管理计算属性
    this._vm = new Vue({
      data: {
        $$state: options.state
      },
      computed
    });
    
    // 注册mutations和actions
    this._mutations = Object.create(null);
    this._actions = Object.create(null);
    
    // 注册mutation处理函数
    forEachValue(options.mutations, (mutation, type) => {
      this._mutations[type] = (payload) => {
        mutation.call(this, this.state, payload);
      };
    });
    
    // 注册action处理函数
    forEachValue(options.actions, (action, type) => {
      this._actions[type] = (payload) => {
        return action.call(this, {
          state: this.state,
          commit: this.commit,
          dispatch: this.dispatch
        }, payload);
      };
    });
  }
  
  // 暴露state的getter
  get state() {
    return this._vm._data.$$state;
  }
  
  // 触发mutation的方法
  commit(type, payload) {
    if (!this._mutations[type]) {
      console.error(`[vuex] unknown mutation type: ${type}`);
      return;
    }
    this._mutations[type](payload);
  }
  
  // 触发action的方法
  dispatch(type, payload) {
    if (!this._actions[type]) {
      console.error(`[vuex] unknown action type: ${type}`);
      return;
    }
    return this._actions[type](payload);
  }
}
```

#### 2. 插件系统

Vuex的插件系统允许拦截状态变更：

```js
// Vuex插件实现示意
function createStore(options) {
  const store = new Store(options);
  
  // 应用插件
  (options.plugins || []).forEach(plugin => plugin(store));
  
  return store;
}

// 插件示例：日志插件
const logPlugin = (store) => {
  store.subscribe((mutation, state) => {
    console.log('mutation', mutation.type, mutation.payload);
    console.log('state after', JSON.stringify(state));
  });
};
```

#### 3. 模块化设计

Vuex通过模块系统组织和管理大型应用：

```js
// 模块注册实现示意
function installModule(store, rootState, path, module) {
  // 设置模块的state
  if (path.length) {
    const parentState = path.slice(0, -1).reduce((state, key) => {
      return state[key];
    }, rootState);
    
    const moduleName = path[path.length - 1];
    Vue.set(parentState, moduleName, module.state);
  }
  
  // 注册模块的getters
  module.forEachGetter((getter, key) => {
    store._registerGetter(path.join('/') + key, getter, module.state);
  });
  
  // 注册模块的mutations
  module.forEachMutation((mutation, key) => {
    store._registerMutation(path.join('/') + key, mutation, module.state);
  });
  
  // 注册模块的actions
  module.forEachAction((action, key) => {
    store._registerAction(path.join('/') + key, action, module.state);
  });
  
  // 递归注册子模块
  module.forEachChild((child, key) => {
    installModule(store, rootState, path.concat(key), child);
  });
}
```

### Pinia核心原理

#### ① 基于Vue 3 Composition API

Pinia充分利用Vue 3的Composition API和响应式系统：

```js
// Pinia核心实现示意
import { reactive, computed, inject, effectScope } from 'vue';

// 创建pinia实例
export function createPinia() {
  // 使用effectScope捕获所有响应式效果
  const scope = effectScope(true);
  
  // 所有store的容器
  const state = scope.run(() => reactive({}));
  
  // Store定义集合
  const _stores = new Map();
  
  // Pinia实例
  const pinia = {
    install(app) {
      // 提供给组件使用
      app.provide('pinia', pinia);
    },
    
    // 使用插件
    use(plugin) {
      plugin(pinia);
      return pinia;
    },
    
    // 存储state
    _s: _stores,
    _e: scope,
    state
  };
  
  return pinia;
}

// 定义store
export function defineStore(id, options) {
  return function useStore() {
    // 获取pinia实例
    const pinia = inject('pinia');
    
    // 如果store已存在则直接返回
    if (pinia._s.has(id)) {
      return pinia._s.get(id);
    }
    
    // 创建store实例
    const { state: stateOption, getters = {}, actions = {} } = options;
    
    // 初始化state
    const state = reactive(stateOption ? stateOption() : {});
    
    // 添加到全局state
    pinia.state[id] = state;
    
    // 处理getters
    const gettersProxy = {};
    Object.keys(getters).forEach(name => {
      gettersProxy[name] = computed(() => {
        const store = pinia._s.get(id);
        return getters[name].call(store, store);
      });
    });
    
    // 合并actions
    const actionsProxy = {};
    Object.keys(actions).forEach(name => {
      actionsProxy[name] = function() {
        const store = pinia._s.get(id);
        return actions[name].apply(store, arguments);
      };
    });
    
    // 创建store实例
    const store = {
      $id: id,
      ...state,
      ...gettersProxy,
      ...actionsProxy
    };
    
    // 存储store实例
    pinia._s.set(id, store);
    
    return store;
  };
}
```

#### ② 对比Vuex的创新点

 **更简洁的API**：
   - 无需mutations，直接修改state
   - Actions支持同步和异步操作
   - 自动代码拆分

```js
// Vuex中修改状态
store.commit('increment', 1);

// Pinia中修改状态
store.count++;
```

 **更好的TypeScript支持**：

```ts
// Pinia中的TypeScript支持
import { defineStore } from 'pinia';

interface UserState {
  name: string;
  age: number;
}

export const useUserStore = defineStore('user', {
  state: (): UserState => ({
    name: 'John',
    age: 30
  }),
  getters: {
    isAdult(): boolean {
      return this.age >= 18;
    }
  },
  actions: {
    updateAge(newAge: number) {
      this.age = newAge;
    }
  }
});
```

 **devtools支持**：
   - 内置Vue devtools集成
   - 追踪state变化
   - 时间旅行调试

 **组合式store**：

```js
// 组合多个store
import { useUserStore } from './user';
import { useCartStore } from './cart';

export function useCheckout() {
  const user = useUserStore();
  const cart = useCartStore();
  
  function checkout() {
    // 使用多个store中的数据和方法
    return api.checkout({
      userId: user.id,
      items: cart.items
    });
  }
  
  return {
    checkout
  };
}
```

## 8. uniapp转小程序的实现原理

### 架构概览

uniapp能将Vue代码转换为小程序，依赖于其编译器和运行时架构：

```
Vue SFC (.vue文件)
      ↓
  uni-app编译器
      ↓
小程序特定代码 (WXML, WXSS, JS, JSON)
```

### 1. 编译时转换

#### 模板转换

Vue模板被转换为对应小程序平台的模板语法：

```html
<!-- Vue模板 -->
<template>
  <view v-if="show" @click="handleClick" :class="{'active': isActive}">
    {{message}}
  </view>
</template>

<!-- 转换为微信小程序WXML -->
<view wx:if="{{show}}" bindtap="handleClick" class="{{isActive ? 'active' : ''}}">
  {{message}}
</view>
```

核心转换规则：
- `v-if/v-else` → `wx:if/wx:else`
- `v-for` → `wx:for/wx:for-item/wx:for-index`
- `@事件` → `bind事件`
- `:属性` → `属性="{{表达式}}"`

#### 脚本转换

Vue组件的JavaScript部分被转换为小程序Page或Component：

```js
// Vue组件
export default {
  data() {
    return { message: 'Hello' };
  },
  methods: {
    handleClick() {
      this.message = 'Clicked';
    }
  },
  created() {
    console.log('Component created');
  }
}

// 转换为微信小程序Page
Page({
  data: { message: 'Hello' },
  
  handleClick() {
    this.setData({ message: 'Clicked' });
  },
  
  onLoad() {
    console.log('Component created');
  }
});
```

#### 样式转换

CSS样式会被转换为对应小程序的样式文件：

```css
/* Vue组件样式 */
.container {
  display: flex;
  font-size: 28px;
}

/* 转换为小程序WXSS */
.container {
  display: flex;
  font-size: 28rpx; /* px转换为rpx */
}
```

### 2. 运行时适配

#### 生命周期映射

将Vue生命周期映射到小程序生命周期：

```js
const lifecycleMap = {
  'beforeCreate': null,
  'created': 'onLoad',
  'mounted': 'onReady',
  'beforeDestroy': 'onUnload',
  'destroyed': null,
  // 页面特有
  'onShow': 'onShow',
  'onHide': 'onHide',
  'onPullDownRefresh': 'onPullDownRefresh',
  'onReachBottom': 'onReachBottom',
  'onShareAppMessage': 'onShareAppMessage'
};
```

#### 数据响应系统

uni-app提供了轻量级的响应式系统，桥接Vue的响应式和小程序的setData：

```js
// 简化的响应式系统
function createObserver(context) {
  const oldData = JSON.parse(JSON.stringify(context.data));
  let timeout = null;
  
  return {
    update(path, value) {
      // 收集变更
      const changes = {};
      changes[path] = value;
      
      // 批量更新，提高性能
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        context.setData(changes);
      }, 0);
    }
  };
}
```

### 3. 跨平台API封装

uni-app将各平台的API统一封装，屏蔽差异：

```js
// API统一封装示例
function request(options) {
  // #ifdef MP-WEIXIN
  return new Promise((resolve, reject) => {
    wx.request({
      url: options.url,
      data: options.data,
      success: res => {
        resolve(res);
      },
      fail: err => {
        reject(err);
      }
    });
  });
  // #endif
  
  // #ifdef MP-ALIPAY
  return new Promise((resolve, reject) => {
    my.request({
      url: options.url,
      data: options.data,
      success: res => {
        resolve(res);
      },
      fail: err => {
        reject(err);
      }
    });
  });
  // #endif
}
```

### 4. 特殊处理机制

#### 条件编译

通过特殊注释实现平台差异化代码：

```js
// #ifdef MP-WEIXIN
// 仅在微信小程序平台执行的代码
// #endif

// #ifndef H5
// 非H5平台执行的代码
// #endif
```

#### 组件映射

将uni-app组件映射到各平台原生组件：

```js
// 组件映射表
const componentMap = {
  'view': {
    'mp-weixin': 'view',
    'mp-alipay': 'view',
    'mp-baidu': 'view',
    'h5': 'div'
  },
  'text': {
    'mp-weixin': 'text',
    'mp-alipay': 'text',
    'mp-baidu': 'text',
    'h5': 'span'
  }
};
```

#### 自定义组件处理

处理自定义组件的递归编译和传递：

```js
// 自定义组件处理
function processComponent(component, platform) {
  // 处理props
  const props = {};
  Object.keys(component.props || {}).forEach(key => {
    props[key] = {
      type: null,
      value: component.props[key].default
    };
  });
  
  // 转换为小程序组件定义
  return {
    properties: props,
    data: component.data ? component.data() : {},
    methods: component.methods || {},
    lifetimes: {
      attached() {
        // 映射created生命周期
      },
      ready() {
        // 映射mounted生命周期
      },
      detached() {
        // 映射destroyed生命周期
      }
    }
  };
}
```

## 9. Vite和Webpack区别、Vite缺陷

### 核心架构差异

#### Webpack: 打包器(Bundler)
```
源代码 → 解析依赖 → 转换 → 打包 → 输出
```

#### Vite: 开发服务器 + 打包器
```
开发模式: 源代码 → 按需编译(ESM) → 浏览器
生产模式: 源代码 → Rollup打包 → 输出
```

### 开发环境对比

#### Webpack开发服务器:
```js
// Webpack开发服务器工作流
const compiler = webpack(config);
const devServer = new WebpackDevServer(options, compiler);
devServer.listen(8080);

// 整个应用需先打包编译
compiler.hooks.beforeCompile.tap('编译前');
compiler.hooks.compile.tap('编译中');
compiler.hooks.done.tap('编译完成');

// 文件变更时重新编译打包
watching.on('change', (filePath) => {
  // 重新构建整个依赖图
  // 重新打包受影响的模块
});
```

#### Vite开发服务器:
```js
// Vite开发服务器工作流
import { createServer } from 'vite';

const server = await createServer({
  server: { port: 3000 }
});
await server.listen();

// 请求时按需编译
server.middlewares.use(async (req, res, next) => {
  // 浏览器请求ESM模块
  if (req.url.endsWith('.js')) {
    // 仅处理请求的单个文件
    const result = await transformJS(req.url);
    res.end(result);
  }
});

// 文件变更时仅需让浏览器重新请求变更的模块
watcher.on('change', (file) => {
  // 通知浏览器热更新此文件
  // 不需要重新打包整个应用
});
```

### 构建速度与性能

#### 启动时间对比

|         | 小型项目 | 中型项目 | 大型项目 |
| ------- | -------- | -------- | -------- |
| Webpack | 1-3秒    | 5-15秒   | 30秒以上 |
| Vite    | <1秒     | 1-2秒    | 2-5秒    |

```js
// Webpack启动流程
1. 读取配置 → 2. 解析入口 → 3. 构建完整依赖图 → 4. 编译所有模块 → 5. 生成资源 → 6. 启动开发服务器

// Vite启动流程
1. 读取配置 → 2. 启动开发服务器 → 3. 按需编译请求的模块
```

#### 热更新性能

```js
// Webpack HMR
1. 文件变更 → 2. 重新编译模块 → 3. 生成增量更新 → 4. 推送更新 → 5. 客户端应用更新

// Vite HMR
1. 文件变更 → 2. 编译单个模块 → 3. 推送精确更新 → 4. 浏览器重新请求模块
```

### 配置与插件系统

#### Webpack配置示例:
```js
// webpack.config.js
module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'babel-loader',
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({ template: './src/index.html' }),
    new MiniCssExtractPlugin()
  ],
  optimization: {
    splitChunks: { chunks: 'all' }
  }
};
```

#### Vite配置示例:
```js
// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  plugins: [vue()],
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `$injectedColor: orange;`
      }
    }
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router']
        }
      }
    }
  }
});
```

### Vite的主要缺陷

#### 1. 浏览器兼容性限制

```js
// Vite开发模式依赖原生ESM
<script type="module" src="/src/main.js"></script>

// 需要现代浏览器支持
// IE完全不支持
// 某些较旧的Android浏览器也不支持
```

解决方案:
- 开发环境可使用现代浏览器
- 生产环境通过Rollup打包，可配置目标浏览器支持范围

#### 2. 生态系统和插件成熟度

与Webpack相比，Vite的生态系统相对年轻:

```js
// 一些Webpack特有功能在Vite中可能缺失或需要特殊处理
// 例如某些特殊loader
const webpackConfig = {
  module: {
    rules: [
      {
        test: /\.custom$/,
        use: 'custom-webpack-only-loader'
      }
    ]
  }
};

// Vite可能需要专门的插件或变通方案
```

解决方案:
- 检查是否有对应的Vite插件
- 使用兼容Rollup的插件
- 自定义开发插件

#### 3. 服务端渲染(SSR)复杂度

Vite的SSR支持仍在发展中，配置较复杂:

```js
// Vite SSR配置示例
// vite.config.js
export default defineConfig({
  plugins: [
    vue(),
    {
      name: 'vite-plugin-ssr',
      transform(code, id) {
        if (id.endsWith('.vue')) {
          // 处理服务端渲染特殊逻辑
        }
      }
    }
  ],
  ssr: {
    // SSR特定配置
    external: ['some-external-dependency']
  }
});
```

#### 4. 构建大型应用的内存占用

开发大型应用时，Vite可能遇到内存问题:

```
对于包含数千个模块的巨型单页应用，Vite可能会占用大量内存，
因为需要在内存中保存更多的模块转换结果缓存。
```

解决方案:
- 使用`server.fs.strict: true`限制服务目录
- 优化项目结构，减少不必要的文件引入
- 增加Node内存限制: `NODE_OPTIONS='--max-old-space-size=8192'`

#### 5. 预构建依赖的不确定性

Vite会预构建node_modules中的依赖:

```js
// 预构建可能导致某些问题
// vite.config.js
export default defineConfig({
  optimizeDeps: {
    // 手动控制预构建
    include: ['lodash-es', 'vue'],
    exclude: ['problematic-package']
  }
});
```

#### 6. 冷启动性能

对于某些场景，初次访问可能较慢:

```
第一次访问页面时，浏览器需要发起多个HTTP请求获取各个模块，
这可能导致大型应用的初始加载出现"瀑布式"请求延迟。
```

解决方案:
- 使用缓存
- 预热关键模块
- 优化模块依赖图

#### 7. 生产构建差异

开发和生产环境使用不同工具链可能导致差异:

```
开发: Vite原生ESM
生产: Rollup打包

这种差异可能导致某些只在生产环境出现的问题难以在开发阶段发现。
```

解决方案:
- 定期进行生产构建测试
- 使用类似的Rollup配置
- 为关键功能添加端到端测试

## 10. Tree-shaking检测无用代码机制及失效情况

### 基本原理

Tree-shaking是一种静态分析技术，用于消除无用代码(dead code)。其工作原理基于ES模块的静态结构:

```js
// 模块导出
export function used() {
  console.log('This function is used');
}

export function unused() {
  console.log('This function is never imported');
}

// 模块使用
import { used } from './utils';
used(); // unused函数会被tree-shake掉
```

### 检测机制详解

#### 1. 标记阶段(Mark)

构建工具分析整个依赖图，标记哪些导出被使用:

```js
// 简化的标记过程
function markModules(entryModule) {
  const visitedModules = new Set();
  const usedExports = new Map();
  
  function visit(module) {
    if (visitedModules.has(module)) return;
    visitedModules.add(module);
    
    // 分析模块导入
    module.imports.forEach(importDecl => {
      const importedModule = resolveModule(importDecl.source);
      
      // 标记使用的导出
      importDecl.specifiers.forEach(specifier => {
        if (!usedExports.has(importedModule)) {
          usedExports.set(importedModule, new Set());
        }
        usedExports.get(importedModule).add(specifier.imported);
      });
      
      // 递归访问导入的模块
      visit(importedModule);
    });
  }
  
  visit(entryModule);
  return usedExports;
}
```

#### 2. 扫描作用域(Scope Analysis)

分析每个模块内部的变量作用域和依赖关系:

```js
// 简化的作用域分析
function analyzeScope(ast) {
  const scope = new Map();
  const references = new Map();
  
  traverseAst(ast, {
    VariableDeclaration(node) {
      node.declarations.forEach(decl => {
        scope.set(decl.id.name, decl);
      });
    },
    
    Identifier(node, parent) {
      // 判断是否是引用
      if (isReference(node, parent)) {
        references.set(node.name, node);
      }
    }
  });
  
  // 检查未使用的声明
  for (const [name, decl] of scope.entries()) {
    if (!references.has(name)) {
      decl.unused = true;
    }
  }
}
```

#### 3. 消除阶段(Shake)

删除未使用的代码:

```js
// 简化的消除过程
function eliminateDeadCode(ast, usedExports) {
  traverseAst(ast, {
    ExportNamedDeclaration(node, path) {
      // 检查是否是未使用的导出
      if (node.declaration && node.declaration.declarations) {
        const declarations = node.declaration.declarations;
        
        // 过滤掉未使用的导出
        node.declaration.declarations = declarations.filter(decl => {
          const name = decl.id.name;
          return usedExports.has(name);
        });
        
        // 如果全部移除，则移除整个导出声明
        if (node.declaration.declarations.length === 0) {
          path.remove();
        }
      }
    },
    
    // 处理其他类型的未使用代码
    FunctionDeclaration(node, path) {
      if (node.unused && !isExported(node)) {
        path.remove();
      }
    }
  });
}
```

### Tree-shaking检测失效的情况

#### 1. 副作用(Side Effects)

含有副作用的代码不会被移除:

```js
// 存在副作用，不会被tree-shake
export function init() {
  console.log('Module initialized');
}

// 全局副作用
document.title = 'My App'; // 修改全局状态，不会被移除

// 即使未使用，但由于副作用会保留
import './polyfills'; // 包含修改全局原型的代码
```

解决方法:
- 在package.json中标记无副作用模块:
  ```json
  {
    "name": "my-package",
    "sideEffects": false
  }
  ```
- 或者指定有副作用的文件:
  ```json
  {
    "sideEffects": ["*.css", "*/polyfills.js"]
  }
  ```

#### 2. 动态导入和CommonJS

CommonJS模块和动态导入难以静态分析:

```js
// CommonJS导入(无法tree-shake)
const utils = require('./utils');
utils.someFunction();

// 动态导入(无法在编译时确定)
const moduleName = condition ? 'moduleA' : 'moduleB';
import(`./${moduleName}.js`).then(module => {
  module.someFunction();
});
```

解决方法:
- 尽量使用ES模块静态导入
- 将动态部分尽可能小化，静态导入主要功能

#### 3. 间接使用和赋值

通过间接方式使用的代码可能无法被正确分析:

```js
// 通过对象或数组间接使用
export const utilities = {
  formatDate: function() { /* ... */ },
  parseData: function() { /* ... */ }
};

// 在另一个模块中
import { utilities } from './utils';
utilities.formatDate(); // parseData可能无法被tree-shake

// 赋值给变量
import * as utils from './utils';
const { formatDate } = utils; // 可能导致整个模块都被保留
```

#### 4. 导出整个对象

导出整个对象会导致tree-shaking难以分析内部使用情况：

```js
// 不利于tree-shaking的导出方式
export default {
  helper1: function() { /* ... */ },
  helper2: function() { /* ... */ },
  helper3: function() { /* ... */ }
};

// 在另一个模块中
import utils from './utils';
utils.helper1(); // helper2和helper3无法被tree-shake
```

更好的方式是分别导出：

```js
// 有利于tree-shaking的导出方式
export function helper1() { /* ... */ }
export function helper2() { /* ... */ }
export function helper3() { /* ... */ }

// 在另一个模块中
import { helper1 } from './utils';
helper1(); // helper2和helper3会被tree-shake
```

#### 5. 条件编译和环境代码

依赖于环境的代码可能无法被完全tree-shake：

```js
// 开发环境代码
if (process.env.NODE_ENV === 'development') {
  export function debugLog() {
    console.log('Debug info');
  }
}

// 即使在生产环境，如果静态分析无法确定条件结果，可能保留代码
```

解决方法：
- 使用专门的工具处理环境变量（如DefinePlugin）
- 将环境相关代码分离到不同文件

#### 6. 使用eval和Function构造函数

动态执行的代码无法被静态分析：

```js
// 无法被tree-shake
export function dynamicExecute(code) {
  return eval(code);
}

export function createFunction(body) {
  return new Function('a', 'b', body);
}
```

#### 7. IIFE和立即调用

自调用函数会被认为有副作用：

```js
// 即使未被使用也会被保留
export const config = (() => {
  const data = performSomeSetup();
  return { value: data };
})();
```

### 提升Tree-shaking效果的最佳实践

1. **纯函数设计**：
   ```js
   // 好的实践 - 纯函数
   export function add(a, b) {
     return a + b;
   }
   
   // 避免 - 有副作用的函数
   export function add(a, b) {
     const result = a + b;
     console.log(`Adding ${a} + ${b} = ${result}`);
     return result;
   }
   ```

2. **明确的导入导出**：
   ```js
   // 好的实践
   import { specific } from './module';
   
   // 避免
   import * as module from './module';
   ```

3. **使用ES模块语法**：
   ```js
   // 好的实践
   export function method() {}
   import { method } from './module';
   
   // 避免
   module.exports = { method: function() {} };
   const { method } = require('./module');
   ```

4. **合理标记包副作用**：
   ```json
   // package.json
   {
     "name": "my-utils",
     "sideEffects": ["*.css", "./src/polyfills.js"]
   }
   ```

## 11. 项目中做过影响比较深刻的内容

*这个问题需要根据个人经历回答，我提供一个结构化的回答框架和几个示例：*

### 性能优化案例

#### 背景与挑战
- 项目面临的具体性能问题（如首屏加载时间长、列表渲染卡顿等）
- 问题的严重程度及影响范围
- 可量化的性能指标

#### 分析过程
- 使用的性能分析工具（如Chrome DevTools、Lighthouse等）
- 发现的核心问题（如过度渲染、资源加载过大、网络请求过多）
- 定位问题根本原因的思路

#### 解决方案
```js
// 优化前代码示例
const ProductList = () => {
  const [products, setProducts] = useState([]);
  
  useEffect(() => {
    fetchAllProducts().then(data => {
      setProducts(data);
    });
  }, []);
  
  return (
    <div>
      {products.map(product => (
        <ProductItem key={product.id} product={product} />
      ))}
    </div>
  );
};

// 优化后代码示例
const ProductList = () => {
  const [products, setProducts] = useState([]);
  const [page, setPage] = useState(1);
  
  // 实现虚拟列表
  const virtualizedProducts = useVirtualization({
    items: products,
    itemHeight: 120,
    windowHeight: 800
  });
  
  // 分页加载
  useEffect(() => {
    fetchProductsByPage(page).then(data => {
      setProducts(prev => [...prev, ...data]);
    });
  }, [page]);
  
  return (
    <div>
      {virtualizedProducts.map(product => (
        <ProductItem key={product.id} product={product} />
      ))}
      <IntersectionObserver onIntersect={() => setPage(page + 1)} />
    </div>
  );
};
```

#### 实施效果
- 性能提升的量化指标（如首屏加载从5秒减少到1.2秒）
- 用户体验改善（如流畅度提升、交互响应速度加快）
- 业务指标改善（如留存率提升、转化率增加）

### 架构重构案例

#### 背景与挑战
- 原有架构的问题（如耦合度高、可维护性差、扩展困难）
- 业务需求变化带来的新挑战
- 团队面临的开发效率问题

#### 分析与决策
- 各方案的评估过程
- 技术选型考虑因素
- 重构策略（如增量重构、并行开发等）

#### 实施方案
```js
// 重构前：高耦合的模块结构
// UserService.js
export class UserService {
  constructor() {
    this.api = new ApiClient();
    this.analytics = new AnalyticsTracker();
    this.storage = new LocalStorage();
  }
  
  async login(username, password) {
    // 混合了API调用、分析跟踪、本地存储等职责
    const user = await this.api.post('/login', { username, password });
    this.analytics.trackEvent('user_login');
    this.storage.setItem('user', JSON.stringify(user));
    return user;
  }
}

// 重构后：依赖注入、关注点分离
// UserRepository.js
export class UserRepository {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  
  async login(username, password) {
    return this.apiClient.post('/login', { username, password });
  }
}

// UserService.js
export class UserService {
  constructor(userRepository, analytics, storage) {
    this.userRepository = userRepository;
    this.analytics = analytics;
    this.storage = storage;
  }
  
  async login(username, password) {
    const user = await this.userRepository.login(username, password);
    this.analytics.trackEvent('user_login');
    this.storage.setUser(user);
    return user;
  }
}

// 依赖注入容器
const container = new Container();
container.register('apiClient', ApiClient);
container.register('userRepository', UserRepository, ['apiClient']);
container.register('userService', UserService, ['userRepository', 'analytics', 'storage']);
```

#### 实施成果
- 代码质量改善（如测试覆盖率提升、bug减少）
- 开发效率提升（具体数据）
- 新功能的快速交付能力
- 团队协作效率的提升

### 工具链与工程化改进

#### 背景与挑战
- 开发流程的痛点（如部署复杂、环境不一致等）
- CI/CD管道的效率问题
- 代码质量保障机制不足

#### 解决方案
- 引入的新工具与实践
- 自动化流程的建立
- 标准化的推进过程

```js
// 构建工具配置示例
// 优化前的webpack配置
module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
};

// 优化后的模块化配置
const commonConfig = require('./webpack.common');
const prodConfig = require('./webpack.prod');
const devConfig = require('./webpack.dev');

module.exports = (env) => {
  if (env.production) {
    return merge(commonConfig, prodConfig);
  } else {
    return merge(commonConfig, devConfig);
  }
};
```

#### 效果与收益
- 构建时间的缩短（具体数据）
- 部署流程的简化与稳定性
- 团队开发体验的改善
- 产品质量的提升

## 12. TS的type和interface区别、用过哪些ts类型、自定义类型守卫、ts泛型

### type和interface的区别

#### 1. 声明合并能力

**interface支持声明合并**：
```typescript
// 接口可以多次声明，自动合并
interface User {
  name: string;
}

interface User {
  age: number;
}

// 等同于
interface User {
  name: string;
  age: number;
}

// 使用
const user: User = {
  name: "John",
  age: 30
};
```

**type不支持声明合并**：
```typescript
type User = {
  name: string;
};

// 错误：标识符"User"重复
// type User = {
//   age: number;
// };

// 必须一次性定义所有属性
type User = {
  name: string;
  age: number;
};
```

#### 2. 扩展方式不同

**interface使用extends继承**：
```typescript
interface Person {
  name: string;
}

interface User extends Person {
  id: number;
}
```

**type使用交叉类型(&)扩展**：
```typescript
type Person = {
  name: string;
};

type User = Person & {
  id: number;
};
```

#### 3. 类型组合能力

**type可以表达更复杂的类型组合**：
```typescript
// 联合类型
type ID = string | number;

// 元组类型
type Point = [number, number];

// 字面量类型
type Direction = 'north' | 'south' | 'east' | 'west';

// 条件类型
type NonNullable<T> = T extends null | undefined ? never : T;

// 映射类型
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
```

**interface表达能力相对有限**：
```typescript
// interface不能直接表示联合类型
// 不能这样写:
// interface ID = string | number;

// 但可以使用type结合interface
type ID = string | number;
interface User {
  id: ID;
}
```

#### 4. 索引签名和映射类型

**interface的索引签名**：
```typescript
interface Dictionary {
  [key: string]: string;
}
```

**type的映射类型**：
```typescript
type Dictionary = {
  [key: string]: string;
};

// 更灵活的映射类型
type ReadonlyDictionary = {
  readonly [K in string]: string;
};
```

#### 5. 工具类型实现

**用type实现高级工具类型更方便**：
```typescript
// 实现Pick工具类型
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

// 使用示例
interface Person {
  name: string;
  age: number;
  address: string;
}

type PersonNameAndAge = Pick<Person, 'name' | 'age'>;
```

#### 6. 类实现接口

**interface可以被类实现**：
```typescript
interface Shape {
  area(): number;
}

class Circle implements Shape {
  constructor(private radius: number) {}
  
  area() {
    return Math.PI * this.radius * this.radius;
  }
}
```

**type也可以被类实现，但通常使用interface**：
```typescript
type Shape = {
  area(): number;
};

class Rectangle implements Shape {
  constructor(private width: number, private height: number) {}
  
  area() {
    return this.width * this.height;
  }
}
```

### 常用TypeScript类型

#### 1. 基础类型
```typescript
// 基本类型
const num: number = 42;
const str: string = "Hello";
const bool: boolean = true;
const n: null = null;
const u: undefined = undefined;
const sym: symbol = Symbol("sym");
const big: bigint = 100n;

// 字面量类型
const direction: "north" | "south" | "east" | "west" = "north";
const status: 200 | 404 | 500 = 200;
```

#### 2. 数组与元组
```typescript
// 数组类型
const numbers: number[] = [1, 2, 3];
const strings: Array<string> = ["a", "b", "c"];

// 只读数组
const readonlyNumbers: ReadonlyArray<number> = [1, 2, 3];

// 元组类型
const tuple: [string, number, boolean] = ["hello", 42, true];

// 具名元组
const point: [x: number, y: number] = [10, 20];

// 可选元素元组
const record: [string, number?] = ["id-1"];
```

#### 3. 对象类型
```typescript
// 对象类型
interface User {
  id: number;
  name: string;
  email?: string; // 可选属性
  readonly createdAt: Date; // 只读属性
}

// 索引签名
interface Dictionary {
  [key: string]: any;
}

// 嵌套接口
interface Address {
  street: string;
  city: string;
  country: string;
}

interface UserWithAddress extends User {
  address: Address;
}
```

#### 4. 函数类型
```typescript
// 函数类型
type GreetFunction = (name: string) => string;

// 函数接口
interface MathOperation {
  (x: number, y: number): number;
}

// 函数重载
function process(x: number): number;
function process(x: string): string;
function process(x: any): any {
  if (typeof x === "number") {
    return x * 2;
  } else {
    return `processed: ${x}`;
  }
}

// 构造函数类型
interface UserConstructor {
  new (name: string): User;
}
```

#### 5. 工具类型
```typescript
// 内置工具类型
type UserPartial = Partial<User>; // 所有属性变为可选
type UserRequired = Required<User>; // 所有属性变为必需
type UserReadonly = Readonly<User>; // 所有属性变为只读
type UserPick = Pick<User, 'id' | 'name'>; // 选取指定属性
type UserOmit = Omit<User, 'email'>; // 排除指定属性
type UserRecord = Record<'admin' | 'regular', User>; // 创建属性映射
type UserExclude = Exclude<'id' | 'name' | 'email', 'email'>; // 类型排除
type UserExtract = Extract<'id' | 'name' | 'email', 'email' | 'password'>; // 类型提取
type UserNonNullable = NonNullable<string | null | undefined>; // 排除null和undefined
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any; // 提取函数返回类型
```

#### 6. 条件类型和映射类型
```typescript
// 条件类型
type IsString<T> = T extends string ? true : false;
type CheckString = IsString<"hello">; // true
type CheckNumber = IsString<42>; // false

// 分布式条件类型
type Filter<T, U> = T extends U ? T : never;
type FilteredUnion = Filter<string | number | boolean, string | boolean>; // string | boolean

// infer关键字
type GetReturnType<T extends (...args: any) => any> = 
  T extends (...args: any) => infer R ? R : never;
  
type StringFunction = () => string;
type StringReturnType = GetReturnType<StringFunction>; // string

// 映射类型
type Mutable<T> = {
  -readonly [P in keyof T]: T[P]
};

type Optional<T> = {
  [P in keyof T]?: T[P]
};
```

### 自定义类型守卫

类型守卫使TypeScript能够在特定作用域内推断更具体的类型。

#### 1. 使用is关键字
```typescript
// 定义接口
interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

// 类型守卫函数
function isFish(pet: Bird | Fish): pet is Fish {
  return (pet as Fish).swim !== undefined;
}

// 使用类型守卫
function moveAnimal(pet: Bird | Fish) {
  if (isFish(pet)) {
    // TypeScript知道这里pet是Fish类型
    pet.swim();
  } else {
    // TypeScript知道这里pet是Bird类型
    pet.fly();
  }
}
```

#### 2. 使用typeof守卫
```typescript
function process(value: string | number) {
  if (typeof value === "string") {
    // 这里TypeScript知道value是string类型
    return value.toUpperCase();
  } else {
    // 这里TypeScript知道value是number类型
    return value.toFixed(2);
  }
}
```

#### 3. 使用instanceof守卫
```typescript
class Cat {
  meow() {
    return "meow";
  }
}

class Dog {
  bark() {
    return "woof";
  }
}

function makeSound(animal: Cat | Dog) {
  if (animal instanceof Cat) {
    // 这里TypeScript知道animal是Cat类型
    return animal.meow();
  } else {
    // 这里TypeScript知道animal是Dog类型
    return animal.bark();
  }
}
```

#### 4. 使用属性检查守卫
```typescript
interface Square {
  kind: "square";
  size: number;
}

interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}

interface Circle {
  kind: "circle";
  radius: number;
}

type Shape = Square | Rectangle | Circle;

function calculateArea(shape: Shape) {
  // 根据discriminated union模式进行类型守卫
  switch (shape.kind) {
    case "square":
      // TypeScript知道这里shape是Square类型
      return shape.size * shape.size;
    case "rectangle":
      // TypeScript知道这里shape是Rectangle类型
      return shape.width * shape.height;
    case "circle":
      // TypeScript知道这里shape是Circle类型
      return Math.PI * shape.radius ** 2;
  }
}
```

#### 5. 自定义复杂类型守卫
```typescript
// API响应类型
interface SuccessResponse {
  status: 'success';
  data: {
    id: number;
    name: string;
  };
}

interface ErrorResponse {
  status: 'error';
  error: {
    code: number;
    message: string;
  };
}

type ApiResponse = SuccessResponse | ErrorResponse;

// 自定义类型守卫
function isSuccessResponse(response: ApiResponse): response is SuccessResponse {
  return response.status === 'success';
}

// 使用类型守卫处理API响应
function handleResponse(response: ApiResponse) {
  if (isSuccessResponse(response)) {
    // TypeScript知道这里response是SuccessResponse
    console.log(`User: ${response.data.name}`);
  } else {
    // TypeScript知道这里response是ErrorResponse
    console.error(`Error ${response.error.code}: ${response.error.message}`);
  }
}
```

### TypeScript泛型

泛型允许创建可重用的组件，支持多种数据类型。

#### 1. 基本泛型函数
```typescript
// 泛型函数
function identity<T>(arg: T): T {
  return arg;
}

// 使用
const str = identity<string>("hello"); // str类型是string
const num = identity(42); // 类型推导，num类型是number
```

#### 2. 泛型接口和类
```typescript
// 泛型接口
interface Box<T> {
  value: T;
  getValue(): T;
}

// 实现泛型接口
class DataBox<T> implements Box<T> {
  constructor(public value: T) {}
  
  getValue(): T {
    return this.value;
  }
}

// 使用
const stringBox = new DataBox<string>("hello");
const numberBox = new DataBox(123); // 类型推导
```

#### 3. 泛型约束
```typescript
// 带约束的泛型
interface HasLength {
  length: number;
}

function printLength<T extends HasLength>(arg: T): T {
  console.log(`Length: ${arg.length}`);
  return arg;
}

// 使用
printLength("hello"); // 可以，字符串有length属性
printLength([1, 2, 3]); // 可以，数组有length属性
printLength({ length: 10, value: 3 }); // 可以，对象有length属性
// printLength(123); // 错误，数字没有length属性
```

#### 4. 泛型参数默认值
```typescript
// 带默认值的泛型
interface ApiRequest<T = any> {
  data: T;
  method: 'GET' | 'POST';
  url: string;
}

// 默认使用any类型
const getRequest: ApiRequest = {
  data: null,
  method: 'GET',
  url: '/users'
};

// 指定具体类型
interface User {
  id: number;
  name: string;
}

const createUserRequest: ApiRequest<User> = {
  data: { id: 1, name: 'John' },
  method: 'POST',
  url: '/users'
};
```

#### 5. 泛型keyof操作符
```typescript
// 使用keyof与泛型
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = {
  id: 1,
  name: "John",
  email: "john@example.com"
};

// 使用
const userName = getProperty(user, "name"); // 类型安全，返回string
// const invalid = getProperty(user, "age"); // 错误，"age"不存在于user
```

#### 6. 条件类型与泛型
```typescript
// 条件类型与泛型结合
type NonNullable<T> = T extends null | undefined ? never : T;

// 递归条件类型
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

interface User {
  name: string;
  settings: {
    theme: string;
    notifications: {
      email: boolean;
      sms: boolean;
    }
  }
}

// 使用
type ReadonlyUser = DeepReadonly<User>;
// 结果: User的所有属性及嵌套属性都是readonly
```

#### 7. 实用泛型模式
```typescript
// 工厂函数与泛型
interface Widget {
  render(): void;
}

class ButtonWidget implements Widget {
  render() { console.log("Rendering button"); }
}

class InputWidget implements Widget {
  render() { console.log("Rendering input"); }
}

// 通用工厂函数
function createWidget<T extends Widget>(ctor: new () => T): T {
  return new ctor();
}

// 使用
const button = createWidget(ButtonWidget);
const input = createWidget(InputWidget);
```

## 13. 401、304状态码、浏览器缓存策略、HTTP1.0和HTTP2.0区别

### HTTP状态码解析

#### 401 Unauthorized

**含义**：未授权，请求需要用户身份验证。

**典型响应格式**:
```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Basic realm="Corporate Intranet"
Date: Wed, 21 Oct 2023 07:28:00 GMT

{
  "error": "Authentication required",
  "message": "Please provide valid credentials"
}
```

**常见场景**:
- 用户未提供登录凭证
- 提供的凭证无效或已过期
- 访问需要特定权限的资源

**前端处理**:
```javascript
// 响应拦截器示例
axios.interceptors.response.use(
  response => response,
  error => {
    if (error.response && error.response.status === 401) {
      // 清除本地token
      localStorage.removeItem('token');
      
      // 重定向到登录页
      router.push('/login');
      
      // 可选：显示通知
      showNotification('登录已过期，请重新登录');
    }
    return Promise.reject(error);
  }
);
```

#### 304 Not Modified

**含义**：资源未修改，可使用浏览器缓存的版本。

**典型响应格式**:
```http
HTTP/1.1 304 Not Modified
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Cache-Control: max-age=3600
Date: Wed, 21 Oct 2023 07:28:00 GMT
```

**常见场景**:
- 浏览器发送条件请求(If-Modified-Since或If-None-Match)
- 服务器确认资源未被修改
- 告知浏览器继续使用本地缓存的资源

**请求-响应流程**:
1. 浏览器首次请求资源，服务器返回200，带ETag/Last-Modified
2. 浏览器再次请求同一资源，带If-None-Match/If-Modified-Since头
3. 服务器检查资源是否变化
4. 未变化则返回304（无响应体），变化则返回200和新资源

### 浏览器缓存策略

#### 1. 缓存头部解析

```http
Cache-Control: max-age=3600, public
Expires: Wed, 21 Oct 2023 08:28:00 GMT
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
```

**Cache-Control指令**:
- `max-age=秒数`: 资源可缓存的最大秒数
- `public`: 可被任何缓存区缓存(包括中间代理、CDN)
- `private`: 只能被浏览器缓存
- `no-cache`: 每次使用前需要与服务器验证
- `no-store`: 不缓存任何内容
- `stale-while-revalidate=秒数`: 使用旧缓存同时异步验证更新
- `immutable`: 表示资源永不改变

#### 2. 缓存策略分类

**强缓存 (不需要请求服务器)**:
```http
# 优先级高
Cache-Control: max-age=3600

# 优先级低(HTTP/1.0)，会被Cache-Control覆盖
Expires: Wed, 21 Oct 2023 08:28:00 GMT
```

**协商缓存 (需要向服务器验证)**:
```http
# ETag/If-None-Match方式(优先级高)
# 服务器响应
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"

# 浏览器后续请求
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"

# Last-Modified/If-Modified-Since方式(优先级低)
# 服务器响应
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT

# 浏览器后续请求
If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT
```

#### 3. 完整缓存流程

```
浏览器请求资源 --> 
  检查强缓存 -->
    命中强缓存? --> 直接使用缓存内容
    未命中强缓存? -->
      发送请求到服务器 -->
        检查协商缓存 -->
          资源未变化? --> 返回304响应(使用本地缓存)
          资源已变化? --> 返回200响应(新资源内容)
```

#### 4. 缓存策略最佳实践

**HTML文件**:
```http
Cache-Control: no-cache
```
原因：确保用户总是获取最新的页面内容，但仍可利用协商缓存减少传输

**JavaScript/CSS (带版本号)**:
```http
Cache-Control: max-age=31536000, immutable
```
原因：内容变更时会更新文件名/路径，可以长期缓存

**静态资源 (图片、字体等)**:
```http
Cache-Control: max-age=604800, stale-while-revalidate=86400
```
原因：一周强缓存，过期后再使用一天旧缓存同时验证更新

**API响应**:
```http
Cache-Control: private, max-age=0, must-revalidate
```
或针对特定API使用:
```http
Cache-Control: private, max-age=3600
```

#### 5. 前端缓存控制

**禁止缓存敏感页面**:
```html
<meta http-equiv="Cache-Control" content="no-store">
```

**添加版本控制**:
```html
<script src="app.js?v=1.2.3"></script>
```
更好的方式是使用内容哈希:
```html
<script src="app.a3f92e.js"></script>
```

**服务工作者(Service Worker)自定义缓存**:
```javascript
// 缓存策略: 网络优先，失败时回退到缓存
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
      .catch(() => caches.match(event.request))
  );
});
```

### HTTP/1.0和HTTP/2.0的区别

#### 1. 连接管理

**HTTP/1.0**: 
- 每个请求都需要单独建立TCP连接
- 服务器处理完请求后关闭连接
- 下一个请求需要重新建立连接
```
客户端 <-- TCP连接建立 --> 服务器
客户端 <-- HTTP请求/响应 --> 服务器
-- TCP连接关闭 --
客户端 <-- 新TCP连接建立 --> 服务器
客户端 <-- HTTP请求/响应 --> 服务器
-- TCP连接关闭 --
```

**HTTP/1.1**: 
- 引入了持久连接(Keep-Alive)
- 多个请求可复用同一TCP连接
- 但仍然存在队头阻塞问题(前一个响应必须完成后才能发送下一个请求)
```
客户端 <-- TCP连接建立 --> 服务器
客户端 <-- HTTP请求1/响应1 --> 服务器
客户端 <-- HTTP请求2/响应2 --> 服务器
客户端 <-- HTTP请求3/响应3 --> 服务器
-- TCP连接关闭 --
```

**HTTP/2.0**: 
- 单个TCP连接上的多路复用
- 并行处理多个请求和响应
- 解决了队头阻塞问题
```
客户端 <-- TCP连接建立 --> 服务器
     <-- 流1: 请求1/响应1 -->
     <-- 流2: 请求2/响应2 -->      (并行)
     <-- 流3: 请求3/响应3 -->
-- TCP连接关闭 --
```

#### 2. 性能优化特性

**HTTP/2.0新增特性**:

**二进制分帧**:
- HTTP/1.x: 纯文本协议
- HTTP/2: 二进制帧为基本传输单位
```
HTTP/1.1文本格式:
GET /index.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Accept: text/html

HTTP/2二进制帧:
[帧头部(类型,长度,标志,流ID)] + [帧负载(实际数据)]
```

**头部压缩(HPACK)**:
- HTTP/1.x: 每次请求都发送完整头部
- HTTP/2: 维护头部表，只发送差异部分
```
HTTP/1.1多个请求:
请求1: [所有头部字段，很多重复]
请求2: [所有头部字段，很多重复]
请求3: [所有头部字段，很多重复]

HTTP/2多个请求:
请求1: [所有头部字段]
请求2: [仅变化的字段]
请求3: [仅变化的字段]
```

**服务器推送**:
- HTTP/1.x: 客户端必须先请求资源
- HTTP/2: 服务器可主动推送关联资源
```
HTTP/1.1:
客户端: 请求HTML
服务器: 返回HTML
客户端: 解析HTML，发现需要CSS，请求CSS
服务器: 返回CSS
客户端: 发现需要JS，请求JS
服务器: 返回JS

HTTP/2:
客户端: 请求HTML
服务器: 返回HTML，推送关联的CSS和JS
客户端: 直接使用已推送的资源
```

**请求优先级**:
- HTTP/1.x: 无内置优先级机制
- HTTP/2: 可为每个流设置优先级

#### 3. 状态管理

**HTTP/1.0**: 
- 无状态协议
- 使用Cookie维护会话状态

**HTTP/1.1**: 
- 维持无状态特性
- 增强Cookie功能
- 引入持久连接概念

**HTTP/2.0**: 
- 协议层面保持无状态
- 底层机制更高效支持有状态应用

#### 4. 安全性

**HTTP/1.0 & HTTP/1.1**: 
- 可使用HTTP或HTTPS
- HTTPS是可选的

**HTTP/2.0**: 
- 通常要求HTTPS

  

#### 5.总结：HTTP/1.0与HTTP/2.0区别

| 特性       | HTTP/1.0                   | HTTP/2.0                       |
| :--------- | :------------------------- | :----------------------------- |
| 连接特性   | 短连接，每个请求建立新连接 | 多路复用，单连接并行处理多请求 |
| 数据传输   | 文本格式                   | 二进制格式，更高效             |
| 压缩方式   | 仅压缩响应体               | 头部压缩(HPACK算法)            |
| 服务器推送 | 不支持                     | 支持服务器主动推送资源         |
| 请求优先级 | 不支持                     | 支持请求优先级设置             |
| 安全性     | 无强制加密                 | 通常要求HTTPS                  |

性能提升实例：

- HTTP/1.1加载20个资源约需要20个RTT

- HTTP/2.0仅需要1个RTT，提升近20倍

## 14. 首屏加载缓慢优化方案

### 资源优化

- **代码分割**：路由懒加载，按需加载组件
  ```js
  // Vue路由懒加载
  const routes = [
    { 
      path: '/user', 
      component: () => import('./views/User.vue') 
    }
  ]
  
  // React懒加载
  const UserPage = React.lazy(() => import('./pages/User'));
  ```

- **资源压缩**：
  - 代码压缩(Terser/UglifyJS)
  - 图片优化(WebP/Avif格式，适当压缩)
  - CSS/JS压缩及Tree-shaking
  - Gzip/Brotli压缩传输

- **关键CSS抽取**：提取首屏关键CSS内联到HTML中

### 加载策略

- **资源预加载**：
  ```html
  <!-- 预加载关键资源 -->
  <link rel="preload" href="critical.js" as="script">
  <link rel="preload" href="hero.webp" as="image">
  
  <!-- 预连接关键域 -->
  <link rel="preconnect" href="https://api.example.com">
  ```

- **图片懒加载**：使用Intersection Observer实现
  ```js
  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        observer.unobserve(img);
      }
    });
  });
  
  document.querySelectorAll('img[data-src]').forEach(img => {
    observer.observe(img);
  });
  ```

### 渲染优化

- **SSR/SSG**：服务端渲染或静态站点生成提高首屏加载速度
- **骨架屏**：提供视觉反馈，改善用户体验
- **优化阻塞资源**：将非关键JS延迟加载
  ```html
  <script defer src="non-critical.js"></script>
  ```

### 缓存优化

- **ServiceWorker缓存**：实现离线访问和资源缓存策略
  ```js
  // 注册ServiceWorker
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
  }
  
  // sw.js中缓存静态资源
  self.addEventListener('install', event => {
    event.waitUntil(
      caches.open('static-v1').then(cache => {
        return cache.addAll([
          '/',
          '/styles/main.css',
          '/scripts/main.js',
          '/images/logo.png'
        ]);
      })
    );
  });
  ```

## 15. 小程序分包策略

### 分包类型

- **主包**：小程序必须资源，如app.js、app.json等
- **分包**：按需加载的页面和资源
- **独立分包**：可独立于主包运行的分包
- **分包预下载**：进入指定页面时预下载其他分包

### 分包配置

```json
{
  "pages": [
    "pages/index/index",
    "pages/logs/logs"
  ],
  "subpackages": [
    {
      "root": "packageA",
      "pages": [
        "pages/cat/index",
        "pages/dog/index"
      ]
    },
    {
      "root": "packageB",
      "pages": [
        "pages/apple/index",
        "pages/banana/index"
      ],
      "independent": true
    }
  ],
  "preloadRule": {
    "pages/index/index": {
      "network": "all",
      "packages": ["packageA"]
    }
  }
}
```

### 分包优化原则

1. **合理划分**：按功能模块划分，降低首次启动时间
2. **控制主包体积**：主包仅包含首页和公共资源，减少首次加载时间
3. **避免分包引用主包资源**：减少跨包依赖
4. **公共组件下沉**：高复用组件放入主包
5. **静态资源CDN**：大型资源使用CDN，减轻包体积

实际案例：某电商小程序从12MB优化到主包仅1.4MB，首屏加载时间从4.5秒降至1.8秒

## 16. 封装组件考虑的点

### 接口设计原则

1. **Props设计**：
   ```js
   // 良好的props设计示例
   props: {
     value: {
       type: [String, Number],
       default: '',
       required: false,
       validator: val => typeof val === 'string' || typeof val === 'number'
     },
     size: {
       type: String,
       default: 'medium',
       validator: val => ['small', 'medium', 'large'].includes(val)
     }
   }
   ```

2. **事件设计**：
   - 遵循单一职责原则，一个事件只做一件事
   - 命名规范：动词+名词，如`@change`、`@select-item`
   - 携带必要的事件参数，便于父组件处理

3. **插槽设计**：
   ```html
   <!-- 灵活的插槽设计 -->
   <template>
     <div class="card">
       <div class="card-header">
         <slot name="header">默认标题</slot>
       </div>
       <div class="card-body">
         <slot>默认内容</slot>
       </div>
       <div class="card-footer">
         <slot name="footer"></slot>
       </div>
     </div>
   </template>
   ```

### 可复用性与扩展性

1. **组合优于继承**：
   - 使用组合模式构建复杂组件
   - 避免深层组件继承关系

2. **控制反转**：
   ```js
   // 不好的写法：组件内部直接引用其他组件
   import { Dialog } from 'ui-lib';
   
   // 好的写法：通过props或插槽注入依赖
   props: {
     confirmDialog: {
       type: Object,
       default: () => ({})
     }
   }
   ```

### 性能与可维护性

1. **避免过度渲染**：
   ```js
   // 使用computed缓存计算结果
   computed: {
     formattedData() {
       return this.heavyComputation(this.rawData);
     }
   }
   
   // 优化v-for渲染
   <li v-for="item in items" :key="item.id">{{ item.name }}</li>
   ```

2. **状态管理**：
   - 内部状态与外部状态分离
   - 避免组件状态泄露
   - 明确状态更新路径

3. **样式封装**：
   ```vue
   <style scoped>
   /* 使用scoped限制样式作用域 */
   .component { /* ... */ }
   
   /* 提供样式接口 */
   .component[data-theme="dark"] { /* ... */ }
   .component[data-size="large"] { /* ... */ }
   </style>
   ```

### 实际案例：表单组件封装

```vue
<template>
  <div 
    class="custom-input" 
    :class="[`custom-input--${size}`, {'is-disabled': disabled}]"
  >
    <label v-if="label" class="custom-input__label">{{ label }}</label>
    <div class="custom-input__wrapper">
      <slot name="prefix"></slot>
      <input
        ref="input"
        class="custom-input__inner"
        :value="modelValue"
        :type="type"
        :placeholder="placeholder"
        :disabled="disabled"
        @input="handleInput"
        @focus="handleFocus"
        @blur="handleBlur"
      />
      <slot name="suffix"></slot>
    </div>
    <p v-if="errorMessage" class="custom-input__error">{{ errorMessage }}</p>
  </div>
</template>

<script>
export default {
  name: 'CustomInput',
  props: {
    modelValue: [String, Number],
    label: String,
    type: {
      type: String,
      default: 'text'
    },
    size: {
      type: String,
      default: 'medium',
      validator: val => ['small', 'medium', 'large'].includes(val)
    },
    placeholder: String,
    disabled: Boolean,
    errorMessage: String
  },
  emits: ['update:modelValue', 'focus', 'blur', 'input'],
  methods: {
    handleInput(e) {
      this.$emit('update:modelValue', e.target.value);
      this.$emit('input', e);
    },
    handleFocus(e) {
      this.$emit('focus', e);
    },
    handleBlur(e) {
      this.$emit('blur', e);
    },
    focus() {
      this.$refs.input.focus();
    }
  }
}
</script>
```

## 17. var、let、const相关问题

### 变量声明特性比较

| 特性       | var            | let                  | const                        |
| ---------- | -------------- | -------------------- | ---------------------------- |
| 作用域     | 函数作用域     | 块级作用域           | 块级作用域                   |
| 变量提升   | 是             | 否（存在暂时性死区） | 否（存在暂时性死区）         |
| 重复声明   | 允许           | 不允许               | 不允许                       |
| 初始化要求 | 可选           | 可选                 | 必须                         |
| 全局声明   | 成为window属性 | 不成为window属性     | 不成为window属性             |
| 可变性     | 可修改         | 可修改               | 不可修改(对象内部属性可修改) |

### 作用域与变量提升

```js
// var变量提升示例
console.log(a); // undefined (提升了声明但未提升赋值)
var a = 5;

// let的暂时性死区(TDZ)
console.log(b); // ReferenceError: b is not defined
let b = 5;

// 块级作用域示例
{
  var c = 10;
  let d = 20;
  const e = 30;
}
console.log(c); // 10 (var不受块级作用域限制)
console.log(d); // ReferenceError: d is not defined
console.log(e); // ReferenceError: e is not defined
```

### const的常见误区

```js
// const对基本类型值的不可变性
const PI = 3.14;
PI = 3.1415; // TypeError: Assignment to constant variable

// const对复合类型的引用不可变，但内容可变
const user = { name: "张三" };
user.name = "李四"; // 有效，修改了对象的属性
user = {}; // TypeError: Assignment to constant variable

// 实现对象的真正不可变
const frozenUser = Object.freeze({ name: "张三" });
frozenUser.name = "李四"; // 严格模式下报错，非严格模式下静默失败
console.log(frozenUser.name); // "张三"

// 深度冻结函数
function deepFreeze(obj) {
  const propNames = Object.getOwnPropertyNames(obj);
  propNames.forEach(name => {
    const prop = obj[name];
    if (typeof prop === 'object' && prop !== null) {
      deepFreeze(prop);
    }
  });
  return Object.freeze(obj);
}
```

### 实际开发最佳实践

1. **默认使用const**：除非需要重新赋值，否则始终使用const
2. **需要重新赋值时使用let**：摒弃var，避免意外的作用域问题
3. **循环优化**：在循环中使用let确保每次迭代有独立作用域
4. **闭包处理**：使用let解决setTimeout等闭包中的经典问题

```js
// var在循环中的闭包问题
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000); // 输出: 3, 3, 3
}

// let解决闭包问题
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000); // 输出: 0, 1, 2
}
```

## 18. 箭头函数、this相关问题

### 箭头函数特性

1. **没有自己的this**：继承外层作用域的this
2. **没有arguments对象**：需使用剩余参数(...args)
3. **不能作为构造函数**：没有[[Construct]]内部方法
4. **没有prototype属性**
5. **不能改变this指向**：bind/call/apply对箭头函数无效

```js
// 箭头函数基本语法
const add = (a, b) => a + b;

// 返回对象字面量需要括号
const getUser = () => ({ name: 'John', age: 30 });

// 箭头函数中的this
const obj = {
  data: ['A', 'B', 'C'],
  printData: function() {
    // 普通函数，this指向调用对象
    console.log(this.data); // ['A', 'B', 'C']
    
    // 传统解决方案
    const self = this;
    setTimeout(function() {
      console.log(self.data); // ['A', 'B', 'C']
    }, 1000);
    
    // 箭头函数解决方案
    setTimeout(() => {
      console.log(this.data); // ['A', 'B', 'C']，this继承自printData
    }, 1000);
  }
};
```

### this绑定机制

**1. 默认绑定**：
```js
function showThis() {
  console.log(this);
}
showThis(); // window (非严格模式) 或 undefined (严格模式)
```

**2. 隐式绑定**：
```js
const user = {
  name: '张三',
  sayHi() {
    console.log(`你好，我是${this.name}`);
  }
};
user.sayHi(); // 你好，我是张三

// 隐式绑定丢失
const sayHi = user.sayHi;
sayHi(); // 你好，我是undefined (this指向window)
```

**3. 显式绑定**：
```js
function introduce(hobby1, hobby2) {
  console.log(`我是${this.name}，我喜欢${hobby1}和${hobby2}`);
}

const user = { name: '张三' };

// call - 立即调用，参数列表
introduce.call(user, '读书', '旅行'); // 我是张三，我喜欢读书和旅行

// apply - 立即调用，参数数组
introduce.apply(user, ['编程', '音乐']); // 我是张三，我喜欢编程和音乐

// bind - 返回新函数，不立即调用
const userIntroduce = introduce.bind(user);
userIntroduce('游戏', '电影'); // 我是张三，我喜欢游戏和电影

// bind可以部分应用参数
const userIntroduceWithHobby = introduce.bind(user, '篮球');
userIntroduceWithHobby('足球'); // 我是张三，我喜欢篮球和足球
```

**4. new绑定**：
```js
function Person(name) {
  this.name = name;
  console.log(this);
}

const person = new Person('张三'); // Person {name: "张三"}
```

### 绑定优先级

**new绑定 > 显式绑定 > 隐式绑定 > 默认绑定**

```js
// 显式绑定 vs 隐式绑定
const obj1 = { name: 'obj1', foo: function() { console.log(this.name); } };
const obj2 = { name: 'obj2' };

obj1.foo(); // obj1 (隐式绑定)
obj1.foo.call(obj2); // obj2 (显式绑定覆盖隐式绑定)

// new绑定 vs 显式绑定
function Person(name) {
  this.name = name;
}
const obj = { name: 'obj' };
const boundPerson = Person.bind(obj);
const person = new boundPerson('张三');
console.log(person.name); // 张三 (new绑定覆盖了bind的显式绑定)
console.log(obj.name); // obj (未被修改)
```

## 19. setTimeout/setInterval误差及事件循环

### setTimeout/setInterval误差原因

1. **JavaScript单线程执行模型**：JS引擎线程繁忙时，定时器回调延迟执行
2. **最小延迟时间限制**：浏览器对嵌套定时器有最小间隔限制(≥4ms)
3. **定时器精度不足**：浏览器定时器精度通常为1ms或更低
4. **系统负载**：高CPU使用率、页面在后台等情况会增加误差
5. **事件循环机制**：定时器只能在当前任务执行完毕后执行

```js
// 定时器误差示例
console.time('timer');
setTimeout(() => {
  console.timeEnd('timer'); // 预期10ms，实际可能>10ms
}, 10);

// 执行耗时任务导致定时器延迟
setTimeout(() => {
  console.log('定时器触发时间');
}, 100);

// 长时间阻塞JS主线程
const start = Date.now();
while (Date.now() - start < 200) {
  // 阻塞200ms
}
console.log('阻塞结束');
// 定时器会在阻塞结束后立即执行，而非100ms后
```

### 高精度定时方案

```js
// 使用requestAnimationFrame实现更精确的定时
function preciseSleep(ms, callback) {
  const start = performance.now();
  
  function check(timestamp) {
    const elapsed = timestamp - start;
    if (elapsed >= ms) {
      callback();
      return;
    }
    requestAnimationFrame(check);
  }
  
  requestAnimationFrame(check);
}

// 纠偏的setInterval实现
function accurateInterval(fn, delay) {
  let expected = Date.now() + delay;
  let timeout;
  
  function step() {
    const drift = Date.now() - expected;
    fn();
    expected += delay;
    
    // 根据漂移时间调整下一次调用
    const adjustedDelay = Math.max(0, delay - drift);
    timeout = setTimeout(step, adjustedDelay);
  }
  
  timeout = setTimeout(step, delay);
  return () => clearTimeout(timeout);
}
```

### 事件循环(Event Loop)机制

#### 基本概念
- **调用栈(Call Stack)**：执行同步代码
- **任务队列(Task Queue)**：
  - 宏任务(MacroTask)：setTimeout/setInterval/I/O等
  - 微任务(MicroTask)：Promise.then/catch/finally/MutationObserver等
- **事件循环(Event Loop)**：不断检查调用栈是否为空，执行任务队列中的任务

#### 执行顺序
1. 执行同步代码(调用栈中的代码)
2. 执行微任务队列中的所有任务
3. 执行一个宏任务
4. 执行微任务队列中的所有任务
5. 重复3-4步骤

```js
// 事件循环执行顺序示例
console.log('1. 同步任务');

setTimeout(() => {
  console.log('2. 第一个宏任务');
  Promise.resolve().then(() => {
    console.log('3. 第一个宏任务中的微任务');
  });
}, 0);

Promise.resolve().then(() => {
  console.log('4. 第一个微任务');
  setTimeout(() => {
    console.log('5. 第一个微任务中的宏任务');
  }, 0);
});

console.log('6. 同步任务');

// 输出顺序:
// 1. 同步任务
// 6. 同步任务
// 4. 第一个微任务
// 2. 第一个宏任务
// 3. 第一个宏任务中的微任务
// 5. 第一个微任务中的宏任务
```

#### Node.js事件循环特点

Node.js事件循环比浏览器更复杂，包含多个阶段：
- **timers**: 执行setTimeout和setInterval的回调
- **I/O callbacks**: 执行除了close、timers和setImmediate的回调
- **idle, prepare**: 内部使用
- **poll**: 获取新I/O事件，适当阻塞
- **check**: 执行setImmediate回调
- **close callbacks**: 执行close事件回调

```js
// Node.js中的执行顺序
setImmediate(() => {
  console.log('setImmediate');
});

setTimeout(() => {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(() => {
  console.log('Promise');
});

process.nextTick(() => {
  console.log('nextTick');
});

// 输出顺序(可能因环境而略有不同):
// nextTick (优先级最高)
// Promise (微任务)
// setTimeout (宏任务)
// setImmediate (check阶段)
```