# 2025年4月笔记

### 1、重复请求axios封装技术方案
Axios 是一个基于 Promise 网络请求库，常作用于node.js 和浏览器中进行网络资源请求。而作为最常用的公共方法之一，请求封装需要全面考虑可扩展性，如基础配置管理、请求拦截器设计、响应拦截器分层处理、异常捕获、请求取消机制、重复请求处理、请求重试策略、并发队列控制等；

[请求封装参考](https://github.com/GuJiugc/JueJinDemo/blob/main/client/src/axios.js)

### 2、UniApp/Flutter跨平台框架对比
**⚡核心技术对比**
| 维度         | UniApp                            | Flutter                              |
|--------------|-----------------------------------|--------------------------------------|
| 底层原理     | 基于 WebView 渲染（Vue 语法）     | 自研 Skia 引擎直接渲染原生组件       |
| 性能表现     | 接近 Web 性能（H5 水平）          | 接近原生性能（60-120fps 流畅度）     |
| UI 一致性    | 依赖各端 WebView 实现，略有差异   | 像素级一致（Skia 引擎保证）          |
| 热更新支持   | 天然支持（H5 动态更新）           | 禁止热更新（iOS 审核限制）           |
| 优势场景   | 弱类型、前端友好易上手           | 强类型，高性能交互           |


[参考文档](https://doc.dcloud.net.cn/uni-app-x/select.html)

### 3、UniAppX和Flutter相比有哪些优点
对于混合开发框架，主要底层区别来自于调用原生API通信损耗、渲染引擎（自渲染、webview渲染、Weex渲染、原生渲染）等。uni-app x和原生应用是一样的，逻辑层和渲染层都是原生，都是强类型；uni-app x采用uts语言开发，uts语言是基于typescript修改而来的强类型语言，编译到不同平台时有不同的输出：
- 编译到web，输出js
- 编译到Android，输出kotlin
- 编译到iOS，输出swift
- 编译到鸿蒙，输出ets；

**🔧 核心技术架构差异**
| 维度           | UniAppX                           | Flutter                            |
|----------------|----------------------------------|------------------------------------|
| 渲染引擎       | 自研统一渲染管线（URP）          | 基于 Skia 2D 图形库               |
| 语言体系       | 支持 TypeScript + Vue3           | Dart 语言（AOT/JIT 编译）         |
| 底层通信       | 优化版 JavaScriptCore + V8       | 直接调用原生平台通道（Platform Channel） |
| UI 构建方式    | 声明式 Vue 模板                  | Widget 嵌套式编程                 |

[UniAppX Demo](https://doc.dcloud.net.cn/uni-app-x/select.html)

[Flutter渲染Demo](https://gitcode.net/dcloud/test-cross/-/tree/master/test_flutter_slider_100)


### 4、四种实时通信技术：短轮询、长轮询、WebSocket 和 SSE
**短轮询：** 浏览器 定时（如每秒）向服务器发送 HTTP 请求，服务器立即返回当前数据（无论是否有更新）；适用于简单场景，如比分直播界面。

**长轮询：** 浏览器发送 HTTP 请求后，服务器 挂起连接 直到数据更新或超时，返回响应后浏览器立即发起新请求。适用于注册中心 Nacos等场景。

**WebSocket：** 基于 TCP 的全双工协议，通过 HTTP 升级握手,建立持久连接（双向实时通信）。适用于聊天室、在线游戏、协同编辑等 高实时双向交互需求高的场景。

**SSE：** 全称Server Send Event基于 HTTP 协议，服务器可主动推送数据流。SSE 最经典的应用场景是 ： DeepSeek web 聊天界面、股市行情数据，等服务器单向推送需求。

[参考文档](https://mp.weixin.qq.com/s/NIACuNgHtSFgKHc7T1G3Wg)

### 5、🎯 MVP（Minimum Viable Product）是什么
🌰 MVP（最小可行产品）是用最低成本快速验证产品核心价值的迭代开发策略，其核心逻辑可通过以下公式理解：
```text
MVP = 核心痛点解决 × 最小功能集 × 快速验证
```

**🔍 三层要素拆解**

**最小（Minimum）** ——> 功能极简：仅保留最关键的1-3个功能

**可行（Viable）**  ——> 必须能独立解决用户某个具体痛点

**产品（Product）** ——> 需具备完整的使用闭环（输入→处理→输出）

对于资源有限的团队，推荐使用UniApp在2周内完成MVP开发，先用微信小程序验证市场反应，再决定是否用开发高性能版本。


### 6、WeakMap集合使用
**(1)、概述：** WeakMap 是 JavaScript 中一种特殊的键值对集合，与 Map 类似，但有几个关键区别。它的核心特性是弱引用键（Weakly Held Keys），这使得它在内存管理上具有独特优势。

**(2)、特性：** 

**①**  键必须是对象（包括数组函数等应用类型），不能是原始类型。

**②**  弱引用机制：如果键对象在其他地方没有被引用，它会被垃圾回收（GC）自动回收，对应的键值对也会从 WeakMap 中消失。

**③**  无法遍历：没有 `size` 属性，不可查询大小或内容、没有 `keys()/values()/entries()` 方法，也无法用 `for...of` 遍历。

**④** 自动清理：当键对象被销毁时，WeakMap中对应的键值对也会被自动清除，无需手动删除。

**(3)、与Map的区别：** `键类型`：Map任意类型、`垃圾回收`：Map长期持有键，阻止垃圾回收、`可遍历性`：Map支持遍历、`性能`：Map适合长期存储，功能能全面.

**(4)、应用场景：**

**①** 私有属性存储:缓存系统，缓存与对象关联的数据，对象销毁时缓存自动失效。

**②** DOM节点元数据管理：存储DOM节点的关键元数据，节点移除后数据自动清理。

**③** 需要精确控制或遍历键值对时，应使用 Map 或普通对象。
